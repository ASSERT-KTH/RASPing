[{"job_id": "34ebcaee9f0648d7822e820fa5a2cb3c", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_Add", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length + 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "c5b8c7f647cc4f3cb478bfc352af425a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_Mul", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length * 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "8da89ec6f6374504a8c97f11c457a084", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_Div", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length / 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "ff3499025a1642be85e9b57f97560c2f", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_FloorDiv", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7ff43ce81a50>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7ff43ce81a50>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n>       select_last = rasp.Select(rasp.indices, length // 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\nE       TypeError: unsupported operand type(s) for //: 'SelectorWidth' and 'int'\n\nsource/shuffle_dyck2.py:129: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.21s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length // 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "f785efbdcda341f5a4ba2c0186408989", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_Mod", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fad61f819f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fad61f819f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n>       select_last = rasp.Select(rasp.indices, length % 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\nE       TypeError: unsupported operand type(s) for %: 'SelectorWidth' and 'int'\n\nsource/shuffle_dyck2.py:129: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.46s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length % 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "b109aede409f46ef8984e7b796b4beeb", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_Pow", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f6361999930>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f6361999930>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n>       select_last = rasp.Select(rasp.indices, length ** 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\nE       TypeError: unsupported operand type(s) for ** or pow(): 'SelectorWidth' and 'int'\n\nsource/shuffle_dyck2.py:129: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.99s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length ** 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "fdb67c29214447c0961a90f13837b0f7", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_RShift", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fcdd84559f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fcdd84559f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n>       select_last = rasp.Select(rasp.indices, length >> 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\nE       TypeError: unsupported operand type(s) for >>: 'SelectorWidth' and 'int'\n\nsource/shuffle_dyck2.py:129: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.27s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length >> 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "ef34239a923443d2aeed439b6fd62ffa", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_LShift", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f204c261ab0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f204c261ab0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n>       select_last = rasp.Select(rasp.indices, length << 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\nE       TypeError: unsupported operand type(s) for <<: 'SelectorWidth' and 'int'\n\nsource/shuffle_dyck2.py:129: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.98s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length << 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "4000cffed73d4a2cbc653d0626958504", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_BitOr", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length | 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "fcb4f66b219840428c4d5d4be1127870", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_BitAnd", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length & 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "bc3a1bde32b94f6c812de2de0b1a2d56", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_Sub_BitXor", "occurrence": 0, "start_pos": [129, 51], "end_pos": [129, 52], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fdf83561a50>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fdf83561a50>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n>       select_last = rasp.Select(rasp.indices, length ^ 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\nE       TypeError: unsupported operand type(s) for ^: 'SelectorWidth' and 'int'\n\nsource/shuffle_dyck2.py:129: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.98s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length ^ 1, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "51d763dc762b422ab4a741cc29bffc48", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_Add", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ss('Attention patterns can currently only average binary variables. Not:', {0, 1, 2})\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 1.77s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative + (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "35af602ce91e48b884e86c65c4e3af2c", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_Sub", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ss('Attention patterns can currently only average binary variables. Not:', {0, 1, -1})\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 1.81s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative - (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "38952e805e494f32bf3a0e025e29d277", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_Mul", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative * (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "b7ae306b6c0b4e2f883b2c14721dbeb1", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_Div", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssdivision by zero\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 2.38s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative / (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "841f408803f9434886e3704ed3564dee", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_FloorDiv", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fdcb0b71ae0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fdcb0b71ae0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n>           any_negative = any_negative // (balance < 0)\nE           TypeError: unsupported operand type(s) for //: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:110: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.00s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative // (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "3e726223d53d4d9696f12d43e313be70", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_Mod", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f265045dae0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f265045dae0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n>           any_negative = any_negative % (balance < 0)\nE           TypeError: unsupported operand type(s) for %: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:110: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.00s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative % (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "e2401e323ef44f34b2d24a30fe3c0f6d", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_Pow", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f0de3e41a50>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f0de3e41a50>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n>           any_negative = any_negative ** (balance < 0)\nE           TypeError: unsupported operand type(s) for ** or pow(): 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:110: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.79s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative ** (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "73ace651d4504ed0acd07f482e566f2a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_RShift", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fc820f75ae0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fc820f75ae0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n>           any_negative = any_negative >> (balance < 0)\nE           TypeError: unsupported operand type(s) for >>: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:110: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.21s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative >> (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "f82e5a5ae53c43128f3531b125c2e4ec", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_LShift", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f0320995a20>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f0320995a20>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n>           any_negative = any_negative << (balance < 0)\nE           TypeError: unsupported operand type(s) for <<: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:110: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.01s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative << (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "aae230ddabe64440b6ba6be52df466a9", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_BitAnd", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative & (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "f24079e69689446aa7845d97ee4c7efd", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitOr_BitXor", "occurrence": 0, "start_pos": [110, 36], "end_pos": [110, 37], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f1d2fb95a50>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f1d2fb95a50>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n>           any_negative = any_negative ^ (balance < 0)\nE           TypeError: unsupported operand type(s) for ^: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:110: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.00s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative ^ (balance < 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "872054b0e9624eedba090aab69d7b973", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Add", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero + (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "c139d199bfb34549b3e468cc9816af9c", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Add", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero + not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "62db50c969244948873a8c5a79062710", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Sub", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero - (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "afd34893aeb64f658f26833ce51febc0", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Sub", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero - not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "c634956902a24eb1ba577c19cc593abe", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Mul", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero * (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "b39da1f3d1d348459648e1ca330ff753", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Mul", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero * not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "c134a88f4965403292fd14dba685a834", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Div", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssdivision by zero\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 1.39s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero / (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "9d155e6c38d646b2b2052659b1a03ca7", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Div", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssdivision by zero\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 1.91s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero / not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "a8ddffbb64af44b5a07b35b3ab3f6595", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_FloorDiv", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f0f8245d9c0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f0f8245d9c0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n>           all_zero = all_zero // (balance == 0)\nE           TypeError: unsupported operand type(s) for //: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:127: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.97s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero // (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "03f64c2638054118b0e2aeb9bbf062a8", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_FloorDiv", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f03f543d990>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f03f543d990>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n        not_has_neg = (~has_neg).named(\"not_has_neg\")\n>       return (last_zero // not_has_neg).named(\"shuffle_dyck\")\nE       TypeError: unsupported operand type(s) for //: 'Aggregate' and 'Map'\n\nsource/shuffle_dyck2.py:135: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.99s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero // not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "f1247b8d178543a5b6620ec5d34ca6a3", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Mod", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fa58d04db10>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fa58d04db10>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n>           all_zero = all_zero % (balance == 0)\nE           TypeError: unsupported operand type(s) for %: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:127: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.02s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero % (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "35e216ee95954534850f72f202bd3e15", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Mod", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fa10b565b70>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fa10b565b70>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n        not_has_neg = (~has_neg).named(\"not_has_neg\")\n>       return (last_zero % not_has_neg).named(\"shuffle_dyck\")\nE       TypeError: unsupported operand type(s) for %: 'Aggregate' and 'Map'\n\nsource/shuffle_dyck2.py:135: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.00s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero % not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "063f78442f21455e932e90db65367bf0", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Pow", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fdc52e39900>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fdc52e39900>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n>           all_zero = all_zero ** (balance == 0)\nE           TypeError: unsupported operand type(s) for ** or pow(): 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:127: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.01s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero ** (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "30b549c4bfce4ed48809937fa46b146f", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_Pow", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9c0204d960>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9c0204d960>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n        not_has_neg = (~has_neg).named(\"not_has_neg\")\n>       return (last_zero ** not_has_neg).named(\"shuffle_dyck\")\nE       TypeError: unsupported operand type(s) for ** or pow(): 'Aggregate' and 'Map'\n\nsource/shuffle_dyck2.py:135: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.93s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero ** not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "c6513c8e70414828b1e467f901e0eec6", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_RShift", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f4ab568dae0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f4ab568dae0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n>           all_zero = all_zero >> (balance == 0)\nE           TypeError: unsupported operand type(s) for >>: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:127: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.07s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero >> (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "29fff1e2feeb422eb7096d671f3c07da", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_RShift", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f2549365a20>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f2549365a20>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n        not_has_neg = (~has_neg).named(\"not_has_neg\")\n>       return (last_zero >> not_has_neg).named(\"shuffle_dyck\")\nE       TypeError: unsupported operand type(s) for >>: 'Aggregate' and 'Map'\n\nsource/shuffle_dyck2.py:135: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.76s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero >> not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "61835877b7c1461a859d2c26c987a4fc", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_LShift", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9430991ae0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9430991ae0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n>           all_zero = all_zero << (balance == 0)\nE           TypeError: unsupported operand type(s) for <<: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:127: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.98s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero << (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "44c39cc8562b4f9bb8d6b910191b6a55", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_LShift", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f3debc59a50>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f3debc59a50>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n        not_has_neg = (~has_neg).named(\"not_has_neg\")\n>       return (last_zero << not_has_neg).named(\"shuffle_dyck\")\nE       TypeError: unsupported operand type(s) for <<: 'Aggregate' and 'Map'\n\nsource/shuffle_dyck2.py:135: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.10s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero << not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "1dbd8b263ae74895813b7d951cd74d8c", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_BitOr", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero | (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "1cd2e151757e4fc2bde6a609f97aeb80", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_BitOr", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero | not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "44f142756d6b4999a43bdb0809fb83f3", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_BitXor", "occurrence": 0, "start_pos": [127, 28], "end_pos": [127, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f6118371a80>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f6118371a80>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n>           all_zero = all_zero ^ (balance == 0)\nE           TypeError: unsupported operand type(s) for ^: 'Map' and 'Map'\n\nsource/shuffle_dyck2.py:127: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.00s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero ^ (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "2fde12cdc9c748b086f190e8d10f85a5", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceBinaryOperator_BitAnd_BitXor", "occurrence": 1, "start_pos": [135, 22], "end_pos": [135, 23], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f44c5b6d9c0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f44c5b6d9c0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n        not_has_neg = (~has_neg).named(\"not_has_neg\")\n>       return (last_zero ^ not_has_neg).named(\"shuffle_dyck\")\nE       TypeError: unsupported operand type(s) for ^: 'Aggregate' and 'Map'\n\nsource/shuffle_dyck2.py:135: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.01s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -132,7 +132,7 @@\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n     not_has_neg = (~has_neg).named(\"not_has_neg\")\n-    return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n+    return (last_zero ^ not_has_neg).named(\"shuffle_dyck\")\n \n \n def make_shuffle_dyck2() -> rasp.SOp:"}]
[{"job_id": "b5d70c1734fd48d4a1f71269e57d692c", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_NotEq", "occurrence": 0, "start_pos": [70, 36], "end_pos": [70, 38], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -67,7 +67,7 @@\n       pair_balance: SOp mapping an input to a sequence, where every element\n         is the fraction of previous open tokens minus previous close tokens.\n     \"\"\"\n-    bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n+    bools_open = rasp.numerical(sop != open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")"}]
[{"job_id": "1e1af45b48da4ab38b6d216f7a129b15", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_NotEq", "occurrence": 1, "start_pos": [73, 37], "end_pos": [73, 39], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -70,7 +70,7 @@\n     bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n-    bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n+    bools_close = rasp.numerical(sop != close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n     pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))"}]
[{"job_id": "d688e0dc530d44b98235cee901ef2792", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_NotEq", "occurrence": 2, "start_pos": [100, 25], "end_pos": [100, 27], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f498bf99ab0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f498bf99ab0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n>           assert len(pair) != 2\nE           AssertionError\n\nsource/shuffle_dyck2.py:100: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 2.21s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert len(pair) != 2\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "d4c714310d8a4594b94fdd26661451f1", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_NotEq", "occurrence": 3, "start_pos": [125, 27], "end_pos": [125, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[0] != 0\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "dee60f6296db43439992ff87a9d598b7", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_NotEq", "occurrence": 4, "start_pos": [127, 39], "end_pos": [127, 41], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero & (balance != 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "ecb3fe915066431981a9fa779e700e2f", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Lt", "occurrence": 0, "start_pos": [70, 36], "end_pos": [70, 38], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -67,7 +67,7 @@\n       pair_balance: SOp mapping an input to a sequence, where every element\n         is the fraction of previous open tokens minus previous close tokens.\n     \"\"\"\n-    bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n+    bools_open = rasp.numerical(sop < open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")"}]
[{"job_id": "44f851d2df3a463e8a57172e699fca92", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Lt", "occurrence": 1, "start_pos": [73, 37], "end_pos": [73, 39], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -70,7 +70,7 @@\n     bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n-    bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n+    bools_close = rasp.numerical(sop < close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n     pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))"}]
[{"job_id": "789c4600415d4a1cb9ed62cba0b38059", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Lt", "occurrence": 2, "start_pos": [100, 25], "end_pos": [100, 27], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fd831d619f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fd831d619f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n>           assert len(pair) < 2\nE           AssertionError\n\nsource/shuffle_dyck2.py:100: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 2.24s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert len(pair) < 2\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "e71bd13eac44452aa33933ab3e7ab5e2", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Lt", "occurrence": 3, "start_pos": [125, 27], "end_pos": [125, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[0] < 0\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "f165d757c1fb4bc38a47c246e276829e", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Lt", "occurrence": 4, "start_pos": [127, 39], "end_pos": [127, 41], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero & (balance < 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "87dce919d6cf49aebf9ff42340be171b", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_LtE", "occurrence": 0, "start_pos": [70, 36], "end_pos": [70, 38], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -67,7 +67,7 @@\n       pair_balance: SOp mapping an input to a sequence, where every element\n         is the fraction of previous open tokens minus previous close tokens.\n     \"\"\"\n-    bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n+    bools_open = rasp.numerical(sop <= open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")"}]
[{"job_id": "7b993fede0e347659750f805bd6a0c93", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_LtE", "occurrence": 1, "start_pos": [73, 37], "end_pos": [73, 39], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -70,7 +70,7 @@\n     bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n-    bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n+    bools_close = rasp.numerical(sop <= close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n     pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))"}]
[{"job_id": "c23dc12531a74aaa9a0760cfaeacdb33", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_LtE", "occurrence": 2, "start_pos": [100, 25], "end_pos": [100, 27], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert len(pair) <= 2\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "a6db04406d81448faa33b04d187b9745", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_LtE", "occurrence": 3, "start_pos": [125, 27], "end_pos": [125, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[0] <= 0\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "07467ae46c84493cbaea6ced7a8d243b", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_LtE", "occurrence": 4, "start_pos": [127, 39], "end_pos": [127, 41], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero & (balance <= 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "2fd72389b1a94dec9805547c564686e1", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Gt", "occurrence": 0, "start_pos": [70, 36], "end_pos": [70, 38], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -67,7 +67,7 @@\n       pair_balance: SOp mapping an input to a sequence, where every element\n         is the fraction of previous open tokens minus previous close tokens.\n     \"\"\"\n-    bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n+    bools_open = rasp.numerical(sop > open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")"}]
[{"job_id": "02e8d7ddf78043d2a6b620ba91101f04", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Gt", "occurrence": 1, "start_pos": [73, 37], "end_pos": [73, 39], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -70,7 +70,7 @@\n     bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n-    bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n+    bools_close = rasp.numerical(sop > close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n     pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))"}]
[{"job_id": "138b4afed9bb4611a4f5e0744b28f78f", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Gt", "occurrence": 2, "start_pos": [100, 25], "end_pos": [100, 27], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fd7058919f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fd7058919f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n>           assert len(pair) > 2\nE           AssertionError\n\nsource/shuffle_dyck2.py:100: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 2.17s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert len(pair) > 2\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "82ac33a3ee5b46d18c1703a0f16ae299", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Gt", "occurrence": 3, "start_pos": [125, 27], "end_pos": [125, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[0] > 0\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "4f244148eb464261933311e49de2222f", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Gt", "occurrence": 4, "start_pos": [127, 39], "end_pos": [127, 41], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero & (balance > 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "e326029521d845c780d097e900ff5d53", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_GtE", "occurrence": 0, "start_pos": [70, 36], "end_pos": [70, 38], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -67,7 +67,7 @@\n       pair_balance: SOp mapping an input to a sequence, where every element\n         is the fraction of previous open tokens minus previous close tokens.\n     \"\"\"\n-    bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n+    bools_open = rasp.numerical(sop >= open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")"}]
[{"job_id": "ab1de9d8f47442eba44921a1792ffa36", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_GtE", "occurrence": 1, "start_pos": [73, 37], "end_pos": [73, 39], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -70,7 +70,7 @@\n     bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n-    bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n+    bools_close = rasp.numerical(sop >= close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n     pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))"}]
[{"job_id": "5efbc408952549a895a9362a6c5b98eb", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_GtE", "occurrence": 2, "start_pos": [100, 25], "end_pos": [100, 27], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert len(pair) >= 2\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "28a2161d765b4a1b9845a083e365f0d8", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_GtE", "occurrence": 3, "start_pos": [125, 27], "end_pos": [125, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[0] >= 0\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "8d1cc96baad94732a8eacffa50a59033", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_GtE", "occurrence": 4, "start_pos": [127, 39], "end_pos": [127, 41], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero & (balance >= 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "8dc2cf4a58f24be3852bc6b364c38ea7", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Is", "occurrence": 0, "start_pos": [70, 36], "end_pos": [70, 38], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fae11189a20>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fae11189a20>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\nsource/shuffle_dyck2.py:102: in make_shuffle_dyck\n    balance = make_pair_balance(\nsource/shuffle_dyck2.py:70: in make_pair_balance\n    bools_open = rasp.numerical(sop is open_token).named(\"bools_open\")\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:721: in numerical\n    return annotate(sop, encoding=Encoding.NUMERICAL)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nexpr = False, annotations = {'encoding': <Encoding.NUMERICAL: 'numerical'>}\n\n    def annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n      \"\"\"Creates a new expr with added annotations.\"\"\"\n>     new = expr.copy()\nE     AttributeError: 'bool' object has no attribute 'copy'\n\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:160: AttributeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AttributeEr...\n========================= 2 skipped, 1 error in 1.98s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -67,7 +67,7 @@\n       pair_balance: SOp mapping an input to a sequence, where every element\n         is the fraction of previous open tokens minus previous close tokens.\n     \"\"\"\n-    bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n+    bools_open = rasp.numerical(sop is open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")"}]
[{"job_id": "b247f94d41174954a67cbdab8e822fff", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_Is", "occurrence": 1, "start_pos": [73, 37], "end_pos": [73, 39], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f14a2775a80>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f14a2775a80>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\nsource/shuffle_dyck2.py:102: in make_shuffle_dyck\n    balance = make_pair_balance(\nsource/shuffle_dyck2.py:73: in make_pair_balance\n    bools_close = rasp.numerical(sop is close_token).named(\"bools_close\")\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:721: in numerical\n    return annotate(sop, encoding=Encoding.NUMERICAL)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nexpr = False, annotations = {'encoding': <Encoding.NUMERICAL: 'numerical'>}\n\n    def annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n      \"\"\"Creates a new expr with added annotations.\"\"\"\n>     new = expr.copy()\nE     AttributeError: 'bool' object has no attribute 'copy'\n\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:160: AttributeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AttributeEr...\n========================= 2 skipped, 1 error in 1.80s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -70,7 +70,7 @@\n     bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n-    bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n+    bools_close = rasp.numerical(sop is close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n     pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))"}]
[{"job_id": "d974ec9441ed4d08adeda9e9308f7a72", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_IsNot", "occurrence": 0, "start_pos": [70, 36], "end_pos": [70, 38], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fb6a5d85a50>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fb6a5d85a50>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\nsource/shuffle_dyck2.py:102: in make_shuffle_dyck\n    balance = make_pair_balance(\nsource/shuffle_dyck2.py:70: in make_pair_balance\n    bools_open = rasp.numerical(sop is not open_token).named(\"bools_open\")\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:721: in numerical\n    return annotate(sop, encoding=Encoding.NUMERICAL)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nexpr = True, annotations = {'encoding': <Encoding.NUMERICAL: 'numerical'>}\n\n    def annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n      \"\"\"Creates a new expr with added annotations.\"\"\"\n>     new = expr.copy()\nE     AttributeError: 'bool' object has no attribute 'copy'\n\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:160: AttributeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AttributeEr...\n========================= 2 skipped, 1 error in 1.93s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -67,7 +67,7 @@\n       pair_balance: SOp mapping an input to a sequence, where every element\n         is the fraction of previous open tokens minus previous close tokens.\n     \"\"\"\n-    bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n+    bools_open = rasp.numerical(sop is not open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")"}]
[{"job_id": "f7ebbdbbfb97416b8592aa1116ff1de8", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Eq_IsNot", "occurrence": 1, "start_pos": [73, 37], "end_pos": [73, 39], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9324765a50>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9324765a50>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\nsource/shuffle_dyck2.py:102: in make_shuffle_dyck\n    balance = make_pair_balance(\nsource/shuffle_dyck2.py:73: in make_pair_balance\n    bools_close = rasp.numerical(sop is not close_token).named(\"bools_close\")\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:721: in numerical\n    return annotate(sop, encoding=Encoding.NUMERICAL)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nexpr = True, annotations = {'encoding': <Encoding.NUMERICAL: 'numerical'>}\n\n    def annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n      \"\"\"Creates a new expr with added annotations.\"\"\"\n>     new = expr.copy()\nE     AttributeError: 'bool' object has no attribute 'copy'\n\n../../.venv/lib/python3.10/site-packages/tracr/rasp/rasp.py:160: AttributeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AttributeEr...\n========================= 2 skipped, 1 error in 1.98s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -70,7 +70,7 @@\n     bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n     opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n \n-    bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n+    bools_close = rasp.numerical(sop is not close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n     pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))"}]
[{"job_id": "2f2c76216dcc4eb98ca959f065e22925", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_Eq", "occurrence": 0, "start_pos": [108, 31], "end_pos": [108, 32], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[0] == 0\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "ba6f28e5631149aa89befd6ba06b455a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_Eq", "occurrence": 1, "start_pos": [110, 47], "end_pos": [110, 48], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative | (balance == 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "095f919535ba4d65a761af532044502d", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_NotEq", "occurrence": 0, "start_pos": [108, 31], "end_pos": [108, 32], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[0] != 0\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "2eeb2dd8d4e042f48557026b2807d4dc", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_NotEq", "occurrence": 1, "start_pos": [110, 47], "end_pos": [110, 48], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative | (balance != 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "f68f8e1d7f40495e82b9b2817a5aa08a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_LtE", "occurrence": 0, "start_pos": [108, 31], "end_pos": [108, 32], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[0] <= 0\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "0d179f4d8f954263be38f828895a4793", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_LtE", "occurrence": 1, "start_pos": [110, 47], "end_pos": [110, 48], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative | (balance <= 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "78dd311f9d344742ab82c91cd547fb0b", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_Gt", "occurrence": 0, "start_pos": [108, 31], "end_pos": [108, 32], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[0] > 0\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "4a3475cb85ed4e8eb54590ef8ef64d52", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_Gt", "occurrence": 1, "start_pos": [110, 47], "end_pos": [110, 48], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative | (balance > 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "e802b9bfc2c743e383960f24a85aae34", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_GtE", "occurrence": 0, "start_pos": [108, 31], "end_pos": [108, 32], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[0] >= 0\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "77940732a65244b182dcee9e13f56541", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_Lt_GtE", "occurrence": 1, "start_pos": [110, 47], "end_pos": [110, 48], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative | (balance >= 0)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "df2da30c5a9e48fba4992e696c13c67a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_GtE_Eq", "occurrence": 0, "start_pos": [95, 22], "end_pos": [95, 24], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fbeb494d900>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fbeb494d900>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n>       assert len(pairs) == 1\nE       AssertionError\n\nsource/shuffle_dyck2.py:95: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 1.99s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert len(pairs) == 1\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "f184d95005124aceb4c47f630d418fdb", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_GtE_NotEq", "occurrence": 0, "start_pos": [95, 22], "end_pos": [95, 24], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert len(pairs) != 1\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "5659646ca7c94d7a9ca24014bfa0e442", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_GtE_Lt", "occurrence": 0, "start_pos": [95, 22], "end_pos": [95, 24], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f7a92075a20>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f7a92075a20>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n>       assert len(pairs) < 1\nE       AssertionError\n\nsource/shuffle_dyck2.py:95: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 2.16s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert len(pairs) < 1\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "7274b3b2351d4ff4a6b6d733e3b05d14", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_GtE_LtE", "occurrence": 0, "start_pos": [95, 22], "end_pos": [95, 24], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f1e511959c0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f1e511959c0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n>       assert len(pairs) <= 1\nE       AssertionError\n\nsource/shuffle_dyck2.py:95: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 1.96s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert len(pairs) <= 1\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "05d8ed37f1ef47b7aa3f9f7ff9a5c78c", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceComparisonOperator_GtE_Gt", "occurrence": 0, "start_pos": [95, 22], "end_pos": [95, 24], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert len(pairs) > 1\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "b25cd6f0a2e240118828874ffc4aa683", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_USub_UAdd", "occurrence": 0, "start_pos": [76, 75], "end_pos": [76, 76], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, +1))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "0c1efd57d813498da9f8d88308440768", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_USub_Invert", "occurrence": 0, "start_pos": [76, 75], "end_pos": [76, 76], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, ~1))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "00e421624ca640e9bf1aff87f79265dc", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_USub_Not", "occurrence": 0, "start_pos": [76, 75], "end_pos": [76, 76], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, not 1))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "f24793f5c762443698a533e9eeb20ca7", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_Delete_USub", "occurrence": 0, "start_pos": [76, 75], "end_pos": [76, 76], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, 1))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "fd93eb88cda9453598d91b82d397e99a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_Invert_UAdd", "occurrence": 0, "start_pos": [134, 19], "end_pos": [134, 20], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fc7f92499f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fc7f92499f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n>       not_has_neg = (+has_neg).named(\"not_has_neg\")\nE       TypeError: bad operand type for unary +: 'Aggregate'\n\nsource/shuffle_dyck2.py:134: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 2.00s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -131,7 +131,7 @@\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n-    not_has_neg = (~has_neg).named(\"not_has_neg\")\n+    not_has_neg = (+has_neg).named(\"not_has_neg\")\n     return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n \n "}]
[{"job_id": "9181e5a1ceb8497e93f0162c25fe1380", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_Invert_USub", "occurrence": 0, "start_pos": [134, 19], "end_pos": [134, 20], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9d3a259930>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9d3a259930>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n>       not_has_neg = (-has_neg).named(\"not_has_neg\")\nE       TypeError: bad operand type for unary -: 'Aggregate'\n\nsource/shuffle_dyck2.py:134: TypeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - TypeError: ...\n========================= 2 skipped, 1 error in 1.99s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -131,7 +131,7 @@\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n-    not_has_neg = (~has_neg).named(\"not_has_neg\")\n+    not_has_neg = (-has_neg).named(\"not_has_neg\")\n     return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n \n "}]
[{"job_id": "3342d523a7fb46189a66b7051cc2d45d", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_Invert_Not", "occurrence": 0, "start_pos": [134, 19], "end_pos": [134, 20], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7ff13ce31a20>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7ff13ce31a20>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n        any_negative = balances[0] < 0\n        for balance in balances[1:]:\n            any_negative = any_negative | (balance < 0)\n    \n        # Convert to numerical SOp\n        any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named(\n            \"any_negative\"\n        )\n    \n        select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n            \"select_all\"\n        )\n        has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n            \"has_neg\"\n        )\n    \n        # Check if all balances are 0 at the end -> closed all parentheses\n        all_zero = balances[0] == 0\n        for balance in balances[1:]:\n            all_zero = all_zero & (balance == 0)\n    \n        select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n            \"select_last\"\n        )\n        last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n    \n>       not_has_neg = (not has_neg).named(\"not_has_neg\")\nE       AttributeError: 'bool' object has no attribute 'named'\n\nsource/shuffle_dyck2.py:134: AttributeError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AttributeEr...\n========================= 2 skipped, 1 error in 1.89s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -131,7 +131,7 @@\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n-    not_has_neg = (~has_neg).named(\"not_has_neg\")\n+    not_has_neg = (not has_neg).named(\"not_has_neg\")\n     return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n \n "}]
[{"job_id": "63d5cdb96ff54700bfb94ada2f932466", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ReplaceUnaryOperator_Delete_Invert", "occurrence": 0, "start_pos": [134, 19], "end_pos": [134, 20], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssUnsupported RASP expressions:\nshuffle_dyck2: (Non-linear) SequenceMap only supports categorical inputs/outputs.\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 1.86s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -131,7 +131,7 @@\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n \n-    not_has_neg = (~has_neg).named(\"not_has_neg\")\n+    not_has_neg = (has_neg).named(\"not_has_neg\")\n     return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n \n "}]
[{"job_id": "2371a1d25c124be99352c2c08e6b1083", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/AddNot", "occurrence": 0, "start_pos": [95, 11], "end_pos": [95, 26], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fe48235da80>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7fe48235da80>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n>       assert not len(pairs) >= 1\nE       AssertionError\n\nsource/shuffle_dyck2.py:95: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 1.58s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert not len(pairs) >= 1\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "11e5bc79632f43ecb4af79feb545f2e1", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/AddNot", "occurrence": 1, "start_pos": [100, 15], "end_pos": [100, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f3e55a49a80>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f3e55a49a80>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n>           assert not len(pair) == 2\nE           AssertionError\n\nsource/shuffle_dyck2.py:100: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 2.05s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert not len(pair) == 2\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "ddd8689ff93642a692654fe9e7706e25", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 0, "start_pos": [45, 63], "end_pos": [45, 64], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssUnsupported RASP expressions:\nopens: Numerical aggregate only supports 0 as default value.\ncloses: Numerical aggregate only supports 0 as default value.\nopens: Numerical aggregate only supports 0 as default value.\ncloses: Numerical aggregate only supports 0 as default value.\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 2.13s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -42,7 +42,7 @@\n     \"\"\"\n     bools = rasp.numerical(bools)\n     prevs = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ)\n-    return rasp.numerical(rasp.Aggregate(prevs, bools, default=0)).named(\"frac_prevs\")\n+    return rasp.numerical(rasp.Aggregate(prevs, bools, default= 1)).named(\"frac_prevs\")\n \n \n def make_pair_balance(sop: rasp.SOp, open_token: str, close_token: str) -> rasp.SOp:"}]
[{"job_id": "63f9027e02c74ef6a3865ba0584bf637", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 1, "start_pos": [45, 63], "end_pos": [45, 64], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssUnsupported RASP expressions:\nopens: Numerical aggregate only supports 0 as default value.\ncloses: Numerical aggregate only supports 0 as default value.\nopens: Numerical aggregate only supports 0 as default value.\ncloses: Numerical aggregate only supports 0 as default value.\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 1.90s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -42,7 +42,7 @@\n     \"\"\"\n     bools = rasp.numerical(bools)\n     prevs = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ)\n-    return rasp.numerical(rasp.Aggregate(prevs, bools, default=0)).named(\"frac_prevs\")\n+    return rasp.numerical(rasp.Aggregate(prevs, bools, default= -1)).named(\"frac_prevs\")\n \n \n def make_pair_balance(sop: rasp.SOp, open_token: str, close_token: str) -> rasp.SOp:"}]
[{"job_id": "cf9e3f7417b64844bd9501514bd65a5b", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 2, "start_pos": [76, 72], "end_pos": [76, 73], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 2, -1))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "c64a1d19594745bf8b21b614cccb680b", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 3, "start_pos": [76, 72], "end_pos": [76, 73], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 0, -1))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "d9e5553ca0fd4c928f0b427f3305d47a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 4, "start_pos": [76, 76], "end_pos": [76, 77], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, - 2))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "1a0d4b3ac1b14f3f877db55f42674666", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 5, "start_pos": [76, 76], "end_pos": [76, 77], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -73,7 +73,7 @@\n     bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n     closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n \n-    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n+    pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, - 0))\n     return pair_balance.named(\"pair_balance\")\n \n "}]
[{"job_id": "25a4755bcef24f5cbb97f6bb09fdd664", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 6, "start_pos": [95, 25], "end_pos": [95, 26], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert len(pairs) >= 2\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "cb2e5683ce58409782581b7718ee8708", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 7, "start_pos": [95, 25], "end_pos": [95, 26], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -92,7 +92,7 @@\n     Args:\n       pairs: List of pairs of open and close tokens that each should be balanced.\n     \"\"\"\n-    assert len(pairs) >= 1\n+    assert len(pairs) >= 0\n \n     # Compute running balance of each type of parenthesis\n     balances = []"}]
[{"job_id": "3c113bdbbe5e448291094e6019df0b95", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 8, "start_pos": [100, 28], "end_pos": [100, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9a2a5919f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f9a2a5919f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n>           assert len(pair) == 3\nE           AssertionError\n\nsource/shuffle_dyck2.py:100: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 1.99s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert len(pair) == 3\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "1d380f470c5d41bea46ebb98fa030e32", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 9, "start_pos": [100, 28], "end_pos": [100, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f874cb9d9f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f874cb9d9f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in pairs:\n>           assert len(pair) == 1\nE           AssertionError\n\nsource/shuffle_dyck2.py:100: AssertionError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - AssertionError\n========================= 2 skipped, 1 error in 2.06s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -97,7 +97,7 @@\n     # Compute running balance of each type of parenthesis\n     balances = []\n     for pair in pairs:\n-        assert len(pair) == 2\n+        assert len(pair) == 1\n         open_token, close_token = pair\n         balance = make_pair_balance(\n             rasp.tokens, open_token=open_token, close_token=close_token"}]
[{"job_id": "12568837f6864d9089b0297a7a966300", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 10, "start_pos": [108, 28], "end_pos": [108, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[ 1] < 0\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "a82fe9ea3ce74d08af7a6f020a3cee9b", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 11, "start_pos": [108, 28], "end_pos": [108, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[ -1] < 0\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "e1ac918a82b7483e8bde298d949e7625", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 12, "start_pos": [108, 33], "end_pos": [108, 34], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[0] < 1\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "4836b93c1672456ca8207c3d3b67ba65", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 13, "start_pos": [108, 33], "end_pos": [108, 34], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -105,7 +105,7 @@\n         balances.append(balance)\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n-    any_negative = balances[0] < 0\n+    any_negative = balances[0] < -1\n     for balance in balances[1:]:\n         any_negative = any_negative | (balance < 0)\n "}]
[{"job_id": "64b7b837e60e4415894cec1dd9968c9a", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 14, "start_pos": [109, 28], "end_pos": [109, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -106,7 +106,7 @@\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n-    for balance in balances[1:]:\n+    for balance in balances[ 2:]:\n         any_negative = any_negative | (balance < 0)\n \n     # Convert to numerical SOp"}]
[{"job_id": "9400e70342a64a9b81d8782b7ed0d3af", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 15, "start_pos": [109, 28], "end_pos": [109, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -106,7 +106,7 @@\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n-    for balance in balances[1:]:\n+    for balance in balances[ 0:]:\n         any_negative = any_negative | (balance < 0)\n \n     # Convert to numerical SOp"}]
[{"job_id": "1ace19eebb6b4c0e89641cbc5de026bd", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 16, "start_pos": [110, 49], "end_pos": [110, 50], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative | (balance < 1)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "7ab2c61c9db14648b30a804739132851", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 17, "start_pos": [110, 49], "end_pos": [110, 50], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -107,7 +107,7 @@\n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n     for balance in balances[1:]:\n-        any_negative = any_negative | (balance < 0)\n+        any_negative = any_negative | (balance < -1)\n \n     # Convert to numerical SOp\n     any_negative = rasp.numerical(rasp.Map(lambda x: x, any_negative)).named("}]
[{"job_id": "b733dcd7c93847f4b1d54d5767fe3c31", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 18, "start_pos": [120, 78], "end_pos": [120, 79], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssUnsupported RASP expressions:\nhas_neg: Numerical aggregate only supports 0 as default value.\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 1.97s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -117,7 +117,7 @@\n     select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n         \"select_all\"\n     )\n-    has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n+    has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default= 1)).named(\n         \"has_neg\"\n     )\n "}]
[{"job_id": "41fe6ad6aec744dcac5e257469938561", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 19, "start_pos": [120, 78], "end_pos": [120, 79], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssUnsupported RASP expressions:\nhas_neg: Numerical aggregate only supports 0 as default value.\nUNCOMPILABLE MODEL\n.\n\n========================= 1 passed, 2 skipped in 2.26s =========================\n", "test_outcome": "survived", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -117,7 +117,7 @@\n     select_all = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\n         \"select_all\"\n     )\n-    has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default=0)).named(\n+    has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative, default= -1)).named(\n         \"has_neg\"\n     )\n "}]
[{"job_id": "61fab20e806348229743015159bde5b3", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 20, "start_pos": [125, 24], "end_pos": [125, 25], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[ 1] == 0\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "8c886c20b4ef43118d5505b7b8f4b948", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 21, "start_pos": [125, 24], "end_pos": [125, 25], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[ -1] == 0\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "9afb3eaacb134f51bb1b3650259c77bf", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 22, "start_pos": [125, 30], "end_pos": [125, 31], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[0] == 1\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "1e0b4fb8f1eb405a84b0225756ac9f06", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 23, "start_pos": [125, 30], "end_pos": [125, 31], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -122,7 +122,7 @@\n     )\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n-    all_zero = balances[0] == 0\n+    all_zero = balances[0] == -1\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n "}]
[{"job_id": "6400d8e48e494961b44bc0f70f394617", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 24, "start_pos": [126, 28], "end_pos": [126, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -123,7 +123,7 @@\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n-    for balance in balances[1:]:\n+    for balance in balances[ 2:]:\n         all_zero = all_zero & (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named("}]
[{"job_id": "3d1cfecf23854fff846927b12f27d589", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 25, "start_pos": [126, 28], "end_pos": [126, 29], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -123,7 +123,7 @@\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n-    for balance in balances[1:]:\n+    for balance in balances[ 0:]:\n         all_zero = all_zero & (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named("}]
[{"job_id": "5761e469e692433496e4cb36b894ede0", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 26, "start_pos": [127, 42], "end_pos": [127, 43], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero & (balance == 1)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "8586983de7fb4ee28f51187d7fb1d1bc", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 27, "start_pos": [127, 42], "end_pos": [127, 43], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -124,7 +124,7 @@\n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n     for balance in balances[1:]:\n-        all_zero = all_zero & (balance == 0)\n+        all_zero = all_zero & (balance == -1)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n         \"select_last\""}]
[{"job_id": "d076fd344e8b4e3d98b54a4f5484a67d", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 28, "start_pos": [129, 53], "end_pos": [129, 54], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "b08d8dd1268b474ea2c6c4cfbb7e52d7", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/NumberReplacer", "occurrence": 29, "start_pos": [129, 53], "end_pos": [129, 54], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -126,7 +126,7 @@\n     for balance in balances[1:]:\n         all_zero = all_zero & (balance == 0)\n \n-    select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\n+    select_last = rasp.Select(rasp.indices, length - 0, rasp.Comparison.EQ).named(\n         \"select_last\"\n     )\n     last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")"}]
[{"job_id": "5a6d3eb21c824993815b37103f7e5b2f", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ZeroIterationForLoop", "occurrence": 0, "start_pos": [99, 16], "end_pos": [99, 21], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/andre-silva/RASPing\nconfigfile: pyproject.toml\nplugins: anyio-4.8.0\ncollected 3 items\n\ntests/test_shuffle_dyck2.py ssE\n\n==================================== ERRORS ====================================\n________________ ERROR at setup of TestShuffleDyck2.test_model _________________\n\nself = <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f1eae3799f0>\nmethod = <bound method TestShuffleDyck2.test_model of <tests.test_shuffle_dyck2.TestShuffleDyck2 object at 0x7f1eae3799f0>>\n\n    def setup_method(self, method):\n>       self.__setup__(make_shuffle_dyck2(), \"shuffle_dyck2\")\n\ntests/test_shuffle_dyck2.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsource/shuffle_dyck2.py:139: in make_shuffle_dyck2\n    return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npairs = ['()', '{}']\n\n    def make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n        \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n    \n         (As implemented in the RASP paper.)\n    \n        Example usage:\n          shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n          shuffle_dyck2(\"({)}\")\n          >> [1, 1, 1, 1]\n          shuffle_dyck2(\"(){)}\")\n          >> [0, 0, 0, 0, 0]\n    \n        Args:\n          pairs: List of pairs of open and close tokens that each should be balanced.\n        \"\"\"\n        assert len(pairs) >= 1\n    \n        # Compute running balance of each type of parenthesis\n        balances = []\n        for pair in []:\n            assert len(pair) == 2\n            open_token, close_token = pair\n            balance = make_pair_balance(\n                rasp.tokens, open_token=open_token, close_token=close_token\n            ).named(f\"balance_{pair}\")\n            balances.append(balance)\n    \n        # Check if balances where negative anywhere -> parentheses not balanced\n>       any_negative = balances[0] < 0\nE       IndexError: list index out of range\n\nsource/shuffle_dyck2.py:108: IndexError\n=========================== short test summary info ============================\nERROR tests/test_shuffle_dyck2.py::TestShuffleDyck2::test_model - IndexError:...\n========================= 2 skipped, 1 error in 2.15s ==========================\n", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -96,7 +96,7 @@\n \n     # Compute running balance of each type of parenthesis\n     balances = []\n-    for pair in pairs:\n+    for pair in []:\n         assert len(pair) == 2\n         open_token, close_token = pair\n         balance = make_pair_balance("}]
[{"job_id": "18f114d0c8da4d76b52f3975c724bffe", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ZeroIterationForLoop", "occurrence": 1, "start_pos": [109, 19], "end_pos": [109, 31], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -106,7 +106,7 @@\n \n     # Check if balances where negative anywhere -> parentheses not balanced\n     any_negative = balances[0] < 0\n-    for balance in balances[1:]:\n+    for balance in []:\n         any_negative = any_negative | (balance < 0)\n \n     # Convert to numerical SOp"}]
[{"job_id": "969fd6a6ead44023a07c6e682988584c", "mutations": [{"module_path": "source/shuffle_dyck2.py", "operator_name": "core/ZeroIterationForLoop", "occurrence": 2, "start_pos": [126, 19], "end_pos": [126, 31], "operator_args": {}}]}, {"worker_outcome": "normal", "output": "timeout", "test_outcome": "killed", "diff": "--- mutation diff ---\n--- asource/shuffle_dyck2.py\n+++ bsource/shuffle_dyck2.py\n@@ -123,7 +123,7 @@\n \n     # Check if all balances are 0 at the end -> closed all parentheses\n     all_zero = balances[0] == 0\n-    for balance in balances[1:]:\n+    for balance in []:\n         all_zero = all_zero & (balance == 0)\n \n     select_last = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named("}]
